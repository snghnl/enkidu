# Enkidu CLI v1.0.0-final - Specification

## Overview

This document outlines the remaining features and improvements needed to achieve v1.0.0-final release of the Enkidu CLI.

**Current Version**: v1.0.0-alpha  
**Target Version**: v1.0.0-final  
**Target Date**: 2-3 weeks from 2026-02-14  
**Status**: üöß Planning

---

## Goals for v1.0.0-final

Transform v1.0.0-alpha from a functional alpha into a **production-ready, battle-tested release** suitable for public distribution.

### Key Objectives

1. **Complete Core Features** - Implement remaining PRD features (linking, search)
2. **Ensure Quality** - Achieve >80% test coverage
3. **Production-Ready** - Polish UX, error handling, performance
4. **Documentation** - Complete all user and developer docs
5. **Stable API** - Lock down command structure and config schema

---

## Remaining Features

### 1. Wiki-style Linking System üîó

**Priority**: HIGH  
**Effort**: Medium (3-4 days)  
**Dependencies**: None

#### User Stories

As a user, I want to:
- Link notes using `[[note-name]]` syntax
- See which notes link to the current note (backlinks)
- Detect and fix broken links
- Visualize my knowledge graph

#### Technical Specifications

##### 1.1 Link Parser

**File**: `src/core/link/parser.ts`

```typescript
interface WikiLink {
  raw: string;           // [[note-name|Display Text]]
  target: string;        // note-name
  displayText?: string;  // Display Text (optional)
  startIndex: number;    // Position in content
  endIndex: number;
}

// Extract all wiki-links from markdown content
function extractWikiLinks(content: string): WikiLink[]

// Parse individual wiki-link
function parseWikiLink(linkText: string): WikiLink

// Replace wiki-links in content
function replaceWikiLinks(
  content: string, 
  replacer: (link: WikiLink) => string
): string
```

**Implementation**:
- Regex pattern: `/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g`
- Handle edge cases: nested brackets, malformed links
- Support both `[[note]]` and `[[note|display text]]` formats
- Extract line numbers for better error reporting

##### 1.2 Link Resolver

**File**: `src/core/link/resolver.ts`

```typescript
interface ResolvedLink {
  link: WikiLink;
  resolvedPath?: string;  // Absolute path if found
  exists: boolean;
  suggestions?: string[]; // Similar note names if not found
}

// Resolve wiki-link to actual file path
function resolveWikiLink(
  linkTarget: string, 
  pkmRoot: string
): ResolvedLink

// Find note by various strategies
// 1. Exact slug match
// 2. Case-insensitive match
// 3. Fuzzy match with suggestions
function findNoteByLink(target: string, pkmRoot: string): string | null
```

**Resolution Strategy**:
1. Try exact slug match in all notes
2. Try case-insensitive match
3. Search in daily notes (`daily/YYYY/MM/DD`)
4. Provide fuzzy suggestions if not found

##### 1.3 Link Index

**File**: `src/core/link/index.ts`

```typescript
interface LinkIndexEntry {
  slug: string;
  filePath: string;
  outgoingLinks: WikiLink[];    // Links from this note
  incomingLinks: LinkReference[]; // Links to this note (backlinks)
}

interface LinkReference {
  sourceSlug: string;
  sourcePath: string;
  link: WikiLink;
}

class LinkIndex {
  // Build full link index
  async buildIndex(pkmRoot: string): Promise<Map<string, LinkIndexEntry>>
  
  // Get backlinks for a note
  getBacklinks(slug: string): LinkReference[]
  
  // Get outgoing links for a note
  getOutgoingLinks(slug: string): WikiLink[]
  
  // Find broken links
  findBrokenLinks(): BrokenLink[]
  
  // Save/load cache
  async saveCache(cachePath: string): Promise<void>
  async loadCache(cachePath: string): Promise<void>
}
```

**Caching**:
- Save to `.enkidu/cache/links.json`
- Invalidate on note changes
- Rebuild incrementally when possible

##### 1.4 Link Commands

**File**: `src/commands/link.ts`

```bash
# Show backlinks
enkidu link backlinks <slug>
# Output:
# Backlinks to "my-note":
#   - project-ideas (line 15)
#   - daily/2026/02/13 (line 42)

# Show outgoing links
enkidu link show <slug>
# Output:
# Links in "my-note":
#   - [[related-note]] ‚Üí ‚úì exists
#   - [[missing-note]] ‚Üí ‚úó not found (suggestions: missing-notes, my-note)

# Validate all links
enkidu link validate
# Output:
# Checking 127 notes...
# ‚úì 456 links valid
# ‚úó 3 broken links:
#   - project-ideas.md:15 ‚Üí [[old-note]] (deleted?)
#   - daily/2026/02/10.md:8 ‚Üí [[typo-note]] (did you mean: type-note?)

# Export link graph
enkidu link graph --format json > graph.json
enkidu link graph --format dot > graph.dot  # GraphViz format
```

##### 1.5 Integration with Sync

**Requirement**: Convert wiki-links to markdown links for Docusaurus compatibility

**File**: `src/core/sync/link-converter.ts`

```typescript
// Convert [[note-name]] to [Note Title](../path/to/note.md)
function convertWikiLinksToMarkdown(
  content: string,
  linkIndex: LinkIndex,
  pkmRoot: string
): string
```

**Strategy**:
- Resolve wiki-link to actual file
- Get note title from frontmatter
- Calculate relative path from current note
- Replace `[[note]]` with `[Title](../path/to/note.md)`
- Handle broken links gracefully (keep as text or remove)

#### Testing Requirements

- Unit tests for link parser (regex edge cases)
- Unit tests for link resolver (case sensitivity, fuzzy matching)
- Integration tests for link index (build, cache, invalidation)
- E2E tests for link commands
- Test link conversion during sync

#### Documentation

- Add to README.md: Wiki-linking section
- Add examples to GETTING_STARTED.md
- Update sync docs with link conversion behavior

---

### 2. Full-text Search üîç

**Priority**: HIGH  
**Effort**: Medium (3-4 days)  
**Dependencies**: None

#### User Stories

As a user, I want to:
- Search across all my notes quickly
- Find notes by keywords with fuzzy matching
- Filter search by tags, categories, dates
- See search results with context snippets
- Use interactive search with live results

#### Technical Specifications

##### 2.1 Search Indexer

**File**: `src/core/search/indexer.ts`

```typescript
interface SearchDocument {
  slug: string;
  title: string;
  content: string;        // Full text content
  tags: string[];
  category: string;
  type: 'note' | 'daily' | 'blog';
  created: string;
  updated: string;
  filePath: string;
}

class SearchIndexer {
  // Build search index from all notes
  async buildIndex(notes: Note[]): Promise<Fuse<SearchDocument>>
  
  // Add note to index (incremental)
  addToIndex(note: Note): void
  
  // Remove note from index
  removeFromIndex(slug: string): void
  
  // Update note in index
  updateInIndex(note: Note): void
}
```

**Fuse.js Configuration**:
```typescript
const fuseOptions = {
  keys: [
    { name: 'title', weight: 0.4 },
    { name: 'content', weight: 0.3 },
    { name: 'tags', weight: 0.2 },
    { name: 'category', weight: 0.1 },
  ],
  threshold: 0.4,          // 0 = exact, 1 = match anything
  includeScore: true,
  includeMatches: true,    // For highlighting
  minMatchCharLength: 2,
  ignoreLocation: true,    // Search entire content
};
```

##### 2.2 Search Cache

**File**: `src/core/search/cache.ts`

```typescript
interface SearchCache {
  version: string;
  timestamp: number;
  documents: SearchDocument[];
}

class SearchCacheManager {
  // Save search index to cache
  async saveCache(
    documents: SearchDocument[], 
    cachePath: string
  ): Promise<void>
  
  // Load search index from cache
  async loadCache(cachePath: string): Promise<SearchDocument[] | null>
  
  // Invalidate cache
  invalidate(cachePath: string): void
  
  // Check if cache is valid
  isValid(cachePath: string, maxAge: number): boolean
}
```

**Cache Strategy**:
- Save to `.enkidu/cache/search.json`
- Invalidate on any note change
- Optional: Load on startup (config option)
- Include version and timestamp for validation

##### 2.3 Searcher

**File**: `src/core/search/searcher.ts`

```typescript
interface SearchOptions {
  query: string;
  category?: string;
  tag?: string;
  type?: 'note' | 'daily' | 'blog';
  dateFrom?: Date;
  dateTo?: Date;
  limit?: number;
  titleOnly?: boolean;
}

interface SearchResult {
  note: Note;
  score: number;
  matches: SearchMatch[];
}

interface SearchMatch {
  key: string;          // 'title', 'content', 'tags'
  value: string;        // Matched text
  indices: number[][];  // Character positions
  snippet?: string;     // Context snippet (for content)
}

class Searcher {
  constructor(private fuse: Fuse<SearchDocument>) {}
  
  // Execute search
  search(options: SearchOptions): SearchResult[]
  
  // Search title only
  searchTitles(query: string, limit?: number): SearchResult[]
  
  // Generate context snippet
  generateSnippet(content: string, matches: number[][], contextLength: number): string
}
```

##### 2.4 Search Commands

**File**: `src/commands/search.ts`

```bash
# Basic search
enkidu search "keyword"
# Output:
# Found 5 results:
# 
# 1. My Project Note (score: 0.85)
#    projects ‚Ä¢ 2026-02-13
#    ...includes the keyword in the context of the project...
#
# 2. Daily Note 2026-02-10 (score: 0.72)
#    daily ‚Ä¢ 2026-02-10
#    ...mentioned keyword during the meeting...

# Filter by category
enkidu search "react" --category projects

# Filter by tag
enkidu search "tutorial" --tag javascript

# Filter by date range
enkidu search "meeting" --from 2026-02-01 --to 2026-02-14

# Title-only search
enkidu search "Project" --title-only

# Limit results
enkidu search "keyword" --limit 3

# Interactive search (bonus feature)
enkidu search -i
# Opens interactive fuzzy finder with live results as you type
```

##### 2.5 Interactive Search (Optional)

Use a library like `inquirer-autocomplete-prompt` for interactive search:

```typescript
import autocomplete from 'inquirer-autocomplete-prompt';

// Interactive search with live results
async function interactiveSearch(searcher: Searcher) {
  const answer = await inquirer.prompt([
    {
      type: 'autocomplete',
      name: 'note',
      message: 'Search notes:',
      source: async (answersSoFar, input) => {
        if (!input) return [];
        const results = searcher.search({ query: input, limit: 10 });
        return results.map(r => ({
          name: `${r.note.frontmatter.title} (${r.note.slug})`,
          value: r.note.slug,
        }));
      },
    },
  ]);
  
  // Open selected note
  await openNote(answer.note);
}
```

#### Testing Requirements

- Unit tests for search indexer (document extraction)
- Unit tests for searcher (fuzzy matching, filtering)
- Integration tests for cache (save/load/invalidate)
- E2E tests for search commands with various filters
- Performance tests (search should be < 200ms for 1000 notes)

#### Documentation

- Add search examples to README.md
- Document search syntax and filters
- Add search tips to GETTING_STARTED.md
- Document Fuse.js configuration options

---

### 3. Template Management CLI üìù

**Priority**: MEDIUM  
**Effort**: Small (1-2 days)  
**Dependencies**: None

#### User Stories

As a user, I want to:
- List available templates (built-in + custom)
- View template content
- Create custom templates interactively
- Edit existing custom templates
- Copy built-in templates to customize

#### Technical Specifications

##### 3.1 Template Loader Extension

**File**: `src/core/template/loader.ts`

```typescript
interface Template {
  name: string;
  description: string;
  content: string;
  isBuiltIn: boolean;
  path: string;
}

class TemplateLoader {
  // List all templates (built-in + custom)
  async listTemplates(): Promise<Template[]>
  
  // Load template by name
  async loadTemplate(name: string): Promise<Template>
  
  // Save custom template
  async saveTemplate(name: string, content: string, description: string): Promise<void>
  
  // Copy built-in template to custom
  async copyToCustom(builtInName: string, newName: string): Promise<void>
  
  // Delete custom template
  async deleteTemplate(name: string): Promise<void>
}
```

##### 3.2 Template Validator

**File**: `src/core/template/validator.ts`

```typescript
// Validate template structure
function validateTemplate(content: string): {
  valid: boolean;
  errors: string[];
  warnings: string[];
  variables: string[];  // Detected {{variables}}
}

// Check for required sections
// Check for valid frontmatter
// Check for valid variable syntax
```

##### 3.3 Template Commands

**File**: `src/commands/template.ts`

```bash
# List all templates
enkidu template list
# Output:
# Built-in Templates:
#   daily-default     - Daily note with Focus, Notes, Done, Reflections
#   note-default      - Basic note template
#   blog-post         - Blog post with Introduction, Content, Conclusion
#   project           - Project note with Goals, Tasks, Resources
#   meeting           - Meeting notes with Agenda, Action Items
#
# Custom Templates:
#   weekly-review     - Weekly review template
#   book-notes        - Book reading notes

# Show template content
enkidu template show daily-default
# Displays the full template with syntax highlighting

# Create new custom template interactively
enkidu template create my-template
# Prompts:
#   - Template name: my-template
#   - Description: My custom template
#   - Based on (optional): note-default
#   - [Opens editor with base template or blank]

# Copy built-in to customize
enkidu template copy daily-default my-daily
# Copies daily-default to .enkidu/templates/my-daily.md
# Opens in editor for customization

# Edit custom template
enkidu template edit my-template
# Opens .enkidu/templates/my-template.md in editor

# Delete custom template
enkidu template delete my-template
# Confirmation prompt
```

#### Testing Requirements

- Unit tests for template loader (list, load, save)
- Unit tests for template validator
- Integration tests for template commands
- Test template variable substitution

#### Documentation

- Add template management section to README
- Document template format and variables
- Add examples of custom templates

---

### 4. Comprehensive Testing Suite üß™

**Priority**: HIGH  
**Effort**: Large (5-7 days)  
**Dependencies**: All features should be implemented first

#### Goals

- Achieve >80% code coverage
- Ensure all critical paths are tested
- Prevent regressions
- Document expected behavior
- Enable confident refactoring

#### Test Structure

```
packages/cli/tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schema.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ defaults.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ note/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontmatter.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ link/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolver.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backlinks.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ search/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ indexer.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ searcher.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ template/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loader.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ sync/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docusaurus.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transformer.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ fs.test.ts
‚îÇ       ‚îú‚îÄ‚îÄ date.test.ts
‚îÇ       ‚îú‚îÄ‚îÄ slug.test.ts
‚îÇ       ‚îî‚îÄ‚îÄ paths.test.ts
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ daily.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ note.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tag.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ search.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ link.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ workflows/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ daily-workflow.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ note-workflow.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ publish-workflow.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îÇ       ‚îú‚îÄ‚îÄ sample-notes/
‚îÇ       ‚îî‚îÄ‚îÄ sample-config.json
‚îî‚îÄ‚îÄ e2e/
    ‚îú‚îÄ‚îÄ full-workflow.test.ts
    ‚îî‚îÄ‚îÄ edge-cases.test.ts
```

#### Testing Strategy

##### Unit Tests (Target: 85% coverage)

**What to test**:
- Pure functions (utilities, parsers, validators)
- Business logic (note operations, config management)
- Edge cases (empty input, malformed data, etc.)
- Error handling

**Example**:
```typescript
// tests/unit/note/frontmatter.test.ts
import { describe, it, expect } from 'vitest';
import { parseFrontmatter, stringifyFrontmatter } from '../../../src/core/note/frontmatter';

describe('parseFrontmatter', () => {
  it('should parse valid frontmatter', () => {
    const content = `---
title: Test Note
tags: [test]
---
Content here`;

    const result = parseFrontmatter(content);
    expect(result.frontmatter.title).toBe('Test Note');
    expect(result.frontmatter.tags).toEqual(['test']);
    expect(result.content).toBe('Content here');
  });

  it('should handle missing frontmatter', () => {
    const content = 'Just content';
    const result = parseFrontmatter(content);
    expect(result.frontmatter).toEqual({});
    expect(result.content).toBe('Just content');
  });

  it('should handle malformed frontmatter', () => {
    const content = `---
invalid yaml: [unclosed
---`;
    expect(() => parseFrontmatter(content)).toThrow();
  });
});
```

##### Integration Tests (Target: 80% coverage)

**What to test**:
- Command execution
- File system operations
- Config persistence
- Multi-step workflows

**Example**:
```typescript
// tests/integration/commands/note.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { execSync } from 'child_process';
import { mkdtempSync, rmSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';

describe('note command', () => {
  let testDir: string;

  beforeEach(() => {
    testDir = mkdtempSync(join(tmpdir(), 'pkm-test-'));
    execSync(`node dist/cli.js init --dir ${testDir}`, { 
      input: `${testDir}\nvim\n\n`,
      encoding: 'utf-8' 
    });
  });

  afterEach(() => {
    rmSync(testDir, { recursive: true, force: true });
  });

  it('should create a note', () => {
    const output = execSync(
      `node dist/cli.js note create "Test Note" --category projects`,
      { cwd: testDir, encoding: 'utf-8' }
    );

    expect(output).toContain('Created note: Test Note');
    expect(output).toContain('Slug: test-note');
  });

  it('should list notes', () => {
    execSync(`node dist/cli.js note create "Note 1"`, { cwd: testDir });
    execSync(`node dist/cli.js note create "Note 2"`, { cwd: testDir });

    const output = execSync(`node dist/cli.js note list`, { 
      cwd: testDir, 
      encoding: 'utf-8' 
    });

    expect(output).toContain('Note 1');
    expect(output).toContain('Note 2');
  });
});
```

##### E2E Tests (Target: Key workflows)

**What to test**:
- Complete user workflows
- Cross-feature integration
- Real-world scenarios

**Example**:
```typescript
// tests/e2e/publish-workflow.test.ts
describe('Publishing workflow', () => {
  it('should publish a blog post to Docusaurus', async () => {
    // 1. Init PKM
    // 2. Create blog post
    // 3. Edit and add publish: true
    // 4. Run sync --dry-run
    // 5. Run sync
    // 6. Verify file in Docusaurus blog/
    // 7. Verify frontmatter transformed
    // 8. Verify assets copied
  });
});
```

#### Test Utilities

**File**: `tests/helpers/test-utils.ts`

```typescript
// Create temporary Enkidu directory
export function createTestPkm(): string;

// Cleanup test directory
export function cleanupTestPkm(dir: string): void;

// Create sample notes
export function createSampleNotes(dir: string, count: number): void;

// Mock editor (non-interactive)
export function mockEditor(): void;

// Assert file exists
export function assertFileExists(path: string): void;

// Assert frontmatter equals
export function assertFrontmatterEquals(file: string, expected: any): void;
```

#### Coverage Requirements

- **Overall**: >80%
- **Core modules**: >90% (config, note, link, search, sync)
- **Commands**: >75%
- **Utils**: >85%

#### CI/CD Integration

**File**: `.github/workflows/test.yml`

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Run tests
        run: pnpm test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./packages/cli/coverage/coverage-final.json
```

---

### 5. Error Handling & User Experience Polish ‚ú®

**Priority**: HIGH  
**Effort**: Medium (2-3 days)  
**Dependencies**: All features implemented

#### Improvements Needed

##### 5.1 Better Error Messages

**Current**:
```
Error: Note not found: my-note
```

**Improved**:
```
‚úó Note not found: "my-note"

Did you mean one of these?
  ‚Ä¢ my-notes (in projects/)
  ‚Ä¢ mynote (in reference/)
  ‚Ä¢ my-old-note (in misc/)

Try:
  enkidu note list          # List all notes
  enkidu search "my note"   # Search for notes
```

##### 5.2 Progress Indicators

For long-running operations:

```typescript
import ora from 'ora';

const spinner = ora('Building search index...').start();
// ... operation ...
spinner.succeed('Search index built (127 notes indexed)');
```

Operations to add spinners:
- `enkidu init` - Creating directory structure
- `enkidu sync` - Syncing notes
- `enkidu search` - Building index (first time)
- `enkidu link validate` - Checking all links

##### 5.3 Helpful Hints

Add contextual hints after operations:

```bash
$ enkidu note create "My Note"
‚úì Created note: My Note
  Path: ~/enkidu/notes/misc/my-note.md
  Slug: my-note

üí° Tip: Add tags with --tag javascript --tag tutorial
üí° Tip: Create blog posts with --blog
```

##### 5.4 Validation & Confirmation

Add confirmation for destructive operations:

```typescript
// Before deleting
const { confirm } = await inquirer.prompt([{
  type: 'confirm',
  name: 'confirm',
  message: `Delete "${note.frontmatter.title}"? This cannot be undone.`,
  default: false,
}]);
```

Operations needing confirmation:
- `enkidu note delete` - ‚úÖ Already implemented
- `enkidu sync` - If would overwrite files
- `enkidu tag rename` - Show count of affected notes first

##### 5.5 Logging System

**File**: `src/utils/logger.ts`

Enhance with log levels:

```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

class Logger {
  constructor(private level: LogLevel) {}
  
  debug(message: string): void;
  info(message: string): void;
  warn(message: string): void;
  error(message: string): void;
  success(message: string): void;  // Green checkmark
  
  // Grouped logging
  group(title: string): void;
  groupEnd(): void;
  
  // Tables
  table(data: any[]): void;
}
```

Usage:
```typescript
logger.group('Sync Results');
logger.success('Synced 5 notes');
logger.info('Copied 3 assets');
logger.groupEnd();
```

---

### 6. Performance Optimization ‚ö°

**Priority**: MEDIUM  
**Effort**: Small (1-2 days)  
**Dependencies**: Search, linking implemented

#### Optimizations

##### 6.1 Lazy Loading

- Don't load all notes into memory
- Stream large file operations
- Load search index only when needed

##### 6.2 Caching Strategy

Current caches:
- ‚úÖ Search index - `.enkidu/cache/search.json`
- ‚úÖ Link index - `.enkidu/cache/links.json`

Add:
- Note metadata cache - Store frontmatter separately
- Last modified timestamps - Incremental updates

##### 6.3 Parallel Operations

Use Promise.all for independent operations:

```typescript
// When syncing multiple notes
await Promise.all(
  publishableNotes.map(note => syncNote(note))
);
```

##### 6.4 Performance Benchmarks

Target metrics:
- Command startup: < 50ms
- Note creation: < 100ms
- Search (1000 notes): < 200ms
- Link validation: < 500ms
- Sync (10 notes): < 2s

---

## Documentation Requirements

### User Documentation

1. **README.md** - ‚úÖ Complete, update with new features
2. **GETTING_STARTED.md** - ‚úÖ Complete, add linking/search examples
3. **CLI_REFERENCE.md** - üÜï New: Complete command reference
4. **TROUBLESHOOTING.md** - üÜï New: Common issues and solutions
5. **TEMPLATES.md** - üÜï New: Template guide and examples

### Developer Documentation

1. **CONTRIBUTING.md** - üÜï New: How to contribute
2. **ARCHITECTURE.md** - üÜï New: Technical architecture
3. **API.md** - üÜï New: Internal API documentation
4. **TESTING.md** - üÜï New: Testing guide

### Examples

1. **examples/workflows/** - üÜï New: Example workflows
2. **examples/templates/** - üÜï New: Custom template examples
3. **examples/configs/** - üÜï New: Configuration examples

---

## Release Checklist

### Pre-release

- [ ] All features implemented
- [ ] >80% test coverage achieved
- [ ] All tests passing
- [ ] Documentation complete
- [ ] Examples added
- [ ] Performance benchmarks met
- [ ] No critical bugs

### Release Process

1. [ ] Update version to 1.0.0 in package.json
2. [ ] Update CHANGELOG.md with all changes
3. [ ] Create git tag: `git tag v1.0.0`
4. [ ] Build production bundle: `pnpm build`
5. [ ] Test build locally
6. [ ] Publish to npm: `npm publish` (if public)
7. [ ] Create GitHub release
8. [ ] Announce release

### Post-release

- [ ] Monitor for issues
- [ ] Respond to feedback
- [ ] Plan v1.1.0 features
- [ ] Update roadmap

---

## Timeline

### Week 1: Core Features
- Days 1-2: Wiki-linking system
- Days 3-4: Full-text search
- Days 5: Integration and bug fixes

### Week 2: Quality & Testing
- Days 1-3: Unit tests (config, note, utils)
- Days 4-5: Integration tests (commands, workflows)
- Days 6-7: E2E tests, bug fixes

### Week 3: Polish & Release
- Days 1-2: Error handling, UX improvements
- Days 3-4: Documentation
- Days 5: Performance optimization
- Days 6-7: Final testing, release prep

**Total Estimated Time**: 15-21 days

---

## Success Criteria

### Functional

- [ ] All wiki-linking features work
- [ ] Search returns relevant results quickly
- [ ] Template management fully functional
- [ ] All commands documented and tested

### Quality

- [ ] >80% test coverage
- [ ] All tests passing
- [ ] No known critical bugs
- [ ] Performance targets met

### Documentation

- [ ] Complete user documentation
- [ ] Complete developer documentation
- [ ] Examples and tutorials
- [ ] Migration guide from alpha

### Release

- [ ] Published to npm (or ready to publish)
- [ ] GitHub release created
- [ ] Stable API contract
- [ ] Ready for production use

---

## Risks & Mitigation

### Risk: Timeline Slips

**Mitigation**:
- Prioritize core features (linking, search, tests)
- Template management can be v1.1
- Performance optimization can be incremental

### Risk: Test Coverage Target Not Met

**Mitigation**:
- Start testing early
- Focus on critical paths first
- Use TDD for new features

### Risk: Breaking Changes Needed

**Mitigation**:
- Design APIs carefully
- Get feedback on alpha
- Version configuration schema

---

## Migration from v1.0.0-alpha

### Breaking Changes

**None planned** - v1.0.0-final should be fully backward compatible with alpha.

### New Features

Users can opt-in to new features:
- Wiki-linking is optional (can use markdown links)
- Search requires index build (automatic or manual)
- Template management enhances existing system

### Migration Guide

**For Alpha Users**:

1. Backup your Enkidu directory
2. Update CLI: `pnpm install && pnpm build`
3. Rebuild search index: `enkidu search --rebuild` (if implemented)
4. Rebuild link index: `enkidu link validate`
5. Test sync: `enkidu sync --dry-run`
6. Update config if needed
7. Enjoy new features!

---

**Target Release Date**: Early March 2026  
**Status**: üöß Planning Complete, Ready to Implement  
**Next Step**: Begin implementation of wiki-linking system
